import Init.Data.List
import Mathlib.Data.Set.Basic
import Mathlib.Data.Rel
import Mathlib.Logic.Relation

namespace Primitives

inductive Thread : Type where
  | mk: Nat -> Thread
deriving BEq, Repr

abbrev write := "write"
abbrev read := "read"

/-
Actions are of several kinds, which we detail in the course of this article. For now, we
only consider read and write events relative to memory locations. For example, for the
location x, we can have a read of the value 0 noted Rx = 0, or a write of the value 1,
noted Wx = 1. We write proc(e) for the thread holding the event e and addr(e) for its
address, or memory location.
-/
structure Action : Type where
  action : String
  target : String
  -- For read, the value can not be determined at the begining.
  value : Option String
deriving BEq, Repr

/-
-/
structure Event where
  (id : String)   -- Unique identifier
  (t_id : Nat)      -- Thread ID
  (t : Thread)    -- Associated thread
  (ln : Nat)        -- Line number or position
  (a : Action) -- Action performed
deriving BEq, Repr

structure Event₁ where
  po : ℕ
  rf : ℕ
  fr : ℕ

-- We define program order as (e.linenumber < e.linenumber && e.thread_id == e.thread_id)
-- we define cohenrence order as (e.w.target == e.w.target)
def po_rel (e₁ e₂ : Event) : Prop := e₁.ln < e₂.ln ∧ e₁.t_id == e₂.t_id

-- def data_dependency (e₁ e₂ : Event) : Prop :=

-- coherence order: successive writes to the same location, if they're in the same thread we need to maintain data-dependency order,
-- which means the co follows the program order, if they're in different thread, we don't care the line number.
-- The coherence order gives the order in which all the memory writes to a given location have hit that location in memory
-- In this article: https://diy.inria.fr/doc/herd.html#note11, they defined how to calculate the cohenrence orders,
-- but due to the time limitation, we need to reduce the complexities, by just introduce the init write,
-- and also we'are in the compiler level, we don't need to calculate it using lib,
def co_rel (e₁ e₂ : Event) : Prop :=
  e₁.a.action == write ∧ e₂.a.action = write ∧ e₁.a.target = e₂.a.target ∧
  ((e₁.ln < e₂.ln ∧ e₁.t_id = e₂.t_id) ∨ (e₁.t_id ≠ e₂.t_id))

-- @[simp] def trans (r : Event -> Event -> Prop) : Set (Event × Event) :=
--   { p | Relation.TransGen r p.1 p.2 }

@[simp] def irreflexivity {α : Type} (r : α -> α -> Prop) := ¬ (∃ a, (r a a))

@[simp] def comp_tc {α : Type} (lst : List α) (r : α -> α -> Prop) [∀ (a b : α), Decidable (r a b)] : List (α × α) :=
  let pairs := lst.product lst
  pairs.filter (fun p => if r p.1 p.2 then true else false)

@[simp] def acyclic {α : Type} [BEq α] (lst : List α) (r : α -> α -> Prop) [∀ (a b : α), Decidable (r a b)] : Prop :=
  let tc := comp_tc lst r
  ∀p ∈ tc, p.1 ≠ p.2

-- TransGen: https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Relation.TransGen
@[simp] def acyclic_predicates {α : Type} (search_space : List α) (r : α -> α -> Prop) : Prop :=
  ∀ e ∈ search_space, ¬(∃e, Relation.TransGen r e e)

@[simp] def cyclic (r : Event -> Event -> Prop) : Prop := ∃x, Relation.TransGen r x x

-- Step 1: Control flow semantics
def po : Set (Event × Event) := {(a, b) | po_rel a b}

-- From write to read.
@[simp] def rf (e₁ e₂ : Event) : Prop := e₁.a.action == write ∧ e₂.a.action == read ∧ (e₁.a.target == e₂.a.target)

instance (e₁ e₂ : Event) : Decidable (rf e₁ e₂) :=
  show Decidable (e₁.a.action == write ∧ e₂.a.action == read ∧ (e₁.a.target == e₂.a.target)) from
    inferInstanceAs (Decidable (_ ∧ _ ∧ _))

-- Step 2: Data flow semantics
-- The read-from relation rf describes, for any given read, from which write this read could have taken its value.
-- This will give us many possible results for each read event (Wⁿ -> R).
@[simp] def rf.set : Set (Event × Event) := {(a, b) | rf a b}

-- Set of all the writes.
def W : Set (Event) := { x | x.a.action = write }

-- Set of all the writes on a specific location.
def Wx (loc : String) : Set (Event) := { x | x.a.action == write ∧ x.a.target = loc }

-- def rf (e : Event) : Set (Event × Event) := {(a, b) | b.id == e.id } ∩ rf.all_candidates

-- For each event, they may have one or more candidate

-- We can provide a db to this function so that the caller can fetch the value via index.
def get_set {α : Type} (db : List (Set α)) (i : Fin db.length) : Set (Set α) := { db.get i }

-- The set of all unions of elements taken from each of the sets S₁, S₂, ..., Sₙ.
-- Generated by Claude sama.
def cross {α : Type} {n : ℕ} (S : Fin n -> Set (Set α)) : Set (Set α) :=
  { s | ∃ (e : Fin n → Set α), (∀ i, e i ∈ S i) ∧ s = ⋃ i, e i }

def db.mk {α : Type} : List (Set α) := []
def db.add {α : Type} (db : List (Set α)) (elem : Set α) : List (Set α) := db ++ [elem]

--
-- def partitiOnX {α : Type} (loc : String) (s : Set α) : Set (Set α) :=
--   { set |  }

section Test

@[simp] def e₁ := Event.mk "1" 1 (Thread.mk 1) 1 (Action.mk write "x" none)
@[simp] def e₂ := Event.mk "2" 1 (Thread.mk 1) 2 (Action.mk read "x" none)
@[simp] def e₃ := Event.mk "3" 2 (Thread.mk 2) 1 (Action.mk write "y" none)
@[simp] def e₄ := Event.mk "4" 2 (Thread.mk 2) 2 (Action.mk read "y" none)

@[simp] def test_list := [e₁, e₂, e₃, e₄]
-- @[simp] def real_relation (e₁ e₂ : Event) (h : e₁ ∈ test_list ∧ e₂ ∈ test_list) := rf e₁ e₂

@[simp] def test_ayc := acyclic test_list rf

theorem test_a : test_ayc :=
  by
    aesop
    contradiction

end Test

end Primitives
